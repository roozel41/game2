#labels renderer,texture,atlas,sprite,drawing,animation
= Renderer 2D =

The renderer gives you ability to draw 2D sprites on the screen.

The drawn screen can be a lot larger than the screen. The visible portion of the screen is defined using a camera.


== Sprites ==
Sprites are 2D bitmaps.

Due to an optimization issues, all sprites we want to render are located in an *atlas* texture.

Sprites are drawn using the texture regions, which specify the portion of the atlas bitmap ( in pixels ) the sprite is located in.


== Atlas ==
An atlas is a large texture where an artist can place a lot of smaller sprite bitmaps.

*CAUTION* an atlas texture has to have a ^2 ( power of two ) dimensions, and the largest supported dimensions are 1024x1024.

===XML texture definition===

Here's a sample texture region XML file:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<TextureRegion atlasName='khaky_birds_prototype/atlas.png' x='0' y='0' w='320' h='480' alphaOp='none'/>
}}}

It specifies a texture that's contained in atlas `khaky_birds_prototype/atlas.png` and is located in the region (0, 0)->(320, 480), and should be drawn without any alpha test.

===XML render state attrbutes===

  # `atlasName` - name of the atlas from which the texture should be aquired
  # `x`, `y` - upper left corner coordinates ( in pixels )
  # `w`, `h` - texture width and height ( in pixels )
  # `alphaOp` - alpha operation to use:
    * `none` - don't perform any alpha operation
    * `test` - perform a simple alpha test
    * `blend` - dop the alpha blending. When this param is specified, you should also specify the `srcAlphaFunc` and `destAlphaFunc` attributes
  # `srcAlphaFunc`, `destAlphaFunc` - alpha blending functions for the source and destination textures
    * `zero` - don't use the texture
    * `one` - use texture color and alpha
    * `srcAlpha` - use source texture alpha
    * `destAlpha` - use destination texture alpha
    * `srcColor` - use source texture color
    * `destColor` - use destination texture color
    * `oneMinusSrcAlpha` - use invertex source texture alpha
    * `oneMinusDestAlpha` - use invertex destination texture alpha
    * `oneMinusSrcColor` - use invertex source texture color
    * `oneMinusDestColor` - use invertex destination texture color

== Animation ==
An animation is a resource. You can create them manually, or by using a definition stored in an XML file.

===XML animation resource===
To instantiate an animation resource, do this:
{{{
Animation myAnimation = resourcesManager.getResource( Animation.class, "path_to_my_anim/my_anim.xml" );
}}}

The XML file with it could look like so:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<Animation frameDuration='0.1' looped='true' atlasName='khaky_birds_prototype/atlas.png' alphaOp='test'>
        <TextureRegion x='0', y='0' w='100' h='100'/>
</Animation>
}}}

The file must contain a single `<Animation>` tag with an attribute `frameDuration` specifying the duration of a single animation frame. It may also contain regular *render state tags* ( such as `atlasName` or `alphaOp` ) which are described in more detail [#XML_render_state_attrbutes here].

You can also specify whether the animation should be played in a looped mode or not by adding a *looped* attribute to the `Animation` node.

That tag has children - `<TextureRegion>` tags, each of which describes a region in a texture where an animation frame is located.
The order of the tags specifies the order in which the key frames will be played.

===Playing animation===
A resource can't be played by itself. In order to be played, we need to memorize the time of the animation somewhere, and since an animation is a resource, shared between many interested visuals that want to display it, it doesn't fit to keep such a runtime info in a static by nature instance.

That's why the engine offers another tool - `AnimationPlayer`, which allows you to play and mix multiple animations.

First of all, you need to define which animations you want to be able to play. You can do that using this method:
{{{
/**
 * Adds a new animation definition to the player.
 * 
 * @param animation
 * @return              animation index
 */
public int addAnimation( Animation animation );
}}}

and here's how you can go about it:
{{{
// load animations
Animation regularAnimation = resMgr.getResource( Animation.class, "khaky_birds_prototype/pedestrianWalking.xml");
Animation wipeShitOffAnimation = resMgr.getResource( Animation.class, "khaky_birds_prototype/pedestrianWipeShitOff.xml");
                
// create an animation player
m_animationPlayer = new AnimationPlayer();
int ANIM_WALK = m_animationPlayer.addAnimation( regularAnimation );
int ANIM_WIPE_SHIT_OFF = m_animationPlayer.addAnimation( wipeShitOffAnimation );
}}}

So first you load the animations themselves, then you add them to the player. The player returns an ID for each of the added animations, which you'll need in order to switch to playing the specified animation.

You can select an animation you want to play using this ID and the following method of the `AnimationPlayer`:
{{{
/**
 * Selects an active animation.
 * 
 * @param idx   animation index
 */
public void select( int idx );
}}}

An animation player returns a `TextureRegion` you should draw your sprite with. So here's how you animate your sprite:
{{{
batcher.drawSprite( pos.m_x, pos.m_y, bs.getWidth(), bs.getHeight(), m_animationPlayer.getTextureRegion( deltaTime ) ); 
}}}

where `deltaTime` is the time that's elapsed since the last time you called that method.

The `getTextureRegion` method's signature is:
{{{
/**
 * Returns a texture region you should draw your geometry with in this animation frame. 
 * 
 * @param deltaTime
 * @return
 */
public TextureRegion getTextureRegion( float deltaTime );
}}}

== Sprite batcher ==
A device used to draw sprites on the screen.
It uses two methods:

{{{
/**
 * Draws a sprite with the texture defined for the batch.
 * 
 * @param x				sprite center X coordinate
 * @param y				sprite center Y coordinate
 * @param width			desired sprite width
 * @param height		desired sprite height
 * @param region		texture region to draw the sprite with
 */
public void drawSprite( float x, float y, float width, float height, TextureRegion region );

/**
 * Draws a rotated sprite with the texture defined for the batch.
 * 
 * @param x				sprite center X coordinate
 * @param y				sprite center Y coordinate
 * @param width			desired sprite width
 * @param height		desired sprite height
 * @param angle			rotation angle in degrees
 * @param region		texture region to draw the sprite with
 */
public void drawSprite( float x, float y, float width, float height, float angle, TextureRegion region );

}}}

The latter allows to draw rotated sprites.
Both allow to specify the size of the sprite, so we can scale the images to our hearts contents.

== Entity visual ==

Entity's visual aspects are represented using an `EntityVisual` abstract class.
The class contains a method:

{{{
/**
 * Draw self.
 * 
 * @param batcher
 */
public abstract void draw( SpriteBatcher batcher );
}}}

Override this method in your custom implementation to get access to the `SpriteBatcher` instance which you can use to render your objects.

The class should contain applicable `TextureRegion` or `Animation` fields that describe the graphics features you want to draw.


*CAUTION*: The renderer currently uses just a single atlas texture, so you can't specify which texture to select.

==Visuals factory==
You need to set up the `Renderer2DView` instance so that it knows what visual representations it should create for the specific entities.

You achieve that by registering a factory.

Here's a sample registration:

{{{
m_rendererView.register( Bird.class , new EntityVisualFactory() { @Override public EntityVisual instantiate( Entity parentEntity ) { return new BirdVisual( parentEntity ); } } );
}}}

The *register* method takes a class of an entity as its first argument, and the factory that should be used to create the visual representation as the second one.

The factory itself is an interface with a single method *instantiate*:
{{{
public interface EntityVisualFactory extends ObjectFactory< Entity, EntityVisual >
{
        /**
         * The factory method.
         * 
         * @param parentEntity
         * @return
         */
        EntityVisual instantiate( Entity parentEntity );
}
}}}

Implement it as you see above in order to create a representation you desire.

The factory concept this view uses is described in section [GenericFactory Generic factory].